import pandas as pd
import numpy as np

from typing import Optional, List
from .base import OutlierHandlerBase
from ..exceptions import HandlingException, ConfigurationException, InvalidColumnException
from pandas.api.types import is_integer_dtype


class GroupedHandler(OutlierHandlerBase):
    """
    Handler to replace outliers based on the summary statistic (median or mean) 
    calculated from non-outlier data within a specific group.
    """
    
    def __init__(self, *, 
                 group_by: List[str],
                 agg_func: str = 'median',
                 columns: Optional[List[str]] = None):

        super().__init__(method = self.__class__.__name__, columns=columns)
        
        
        if not isinstance(group_by, list) or not all(isinstance(c, str) for c in group_by):
            raise ConfigurationException(
                error_code="CON002",
                method=self.__class__.__name__,
                parameter_context = "group_by",
                suggestion="The 'group_by' parameter must be a list of one or more column names (strings)."
            )

        
        valid_funcs = ['median', 'mean']
        if agg_func not in valid_funcs:
            raise ConfigurationException(
                error_code="CON003",
                method=self.__class__.__name__,
                parameter="agg_func",
                suggestion=f"The aggregation function must be one of: {valid_funcs}."
            )

        self.group_by = group_by
        self.agg_func = agg_func
        
    def apply(self, df: pd.DataFrame, outlier_mask: Optional[pd.DataFrame] = None) -> pd.DataFrame:
        """
        Replaces outliers with the group-specific statistic of the non-outlier data.
        """
        
        self._validate_input(df)

        if outlier_mask is None:                    # TO DO: correct this
            raise HandlingException(
                error_code="HEX001",
                method=self.__class__.__name__,
                suggestion=f"The 'group' method requires an outlier mask generated by a detector."
            )
        
        if not df.index.equals(outlier_mask.index): # TO DO: correct this
            raise HandlingException(
                error_code = "HEX001",
                method = self.__class__.__name__,
                suggestion = "Index mismatch: DataFrame and outlier_mask must have the same index."
            )

        # Check Group Columns
        for col in self.group_by:
            if col not in df.columns:
                raise InvalidColumnException(
                    error_code = "ICE001",
                    method = self.__class__.__name__,
                    missing = [col],
                    suggestion = f"Check missing column from the input DataFrame."
                )
        
        df_clean = df.copy()

        if self.columns is None:
            raise RuntimeError("Validation was done, but self.columns remains None")

        for col in self.columns:
            if col in outlier_mask.columns and col not in self.group_by:
                outliers = outlier_mask[col]
                
                if not outliers.any():
                    continue 

                if is_integer_dtype(df_clean[col].dtype):
                    df_clean[col] = df_clean[col].astype(float)

                # Mark outliers as NaN to exclude them from group calculation
                temp_series = df_clean[col].copy()
                temp_series.loc[outliers] = np.nan

                # Calculate the group-specific statistic for replacement
                grouper_data = [df_clean[c] for c in self.group_by]
                replacements = temp_series.groupby(grouper_data).transform(self.agg_func)    # type: ignore
                
                df_clean.loc[outliers, col] = replacements.loc[outliers]

                remaining_nans = df_clean[col].isna() & outliers
                if remaining_nans.any():
                    global_stat = temp_series.agg(self.agg_func)
                    
                    if pd.isna(global_stat):
                        raise HandlingException(
                            error_code="HEX002",
                            method=self.__class__.__name__,
                            col = col,
                            suggestion=f"The column might contain only outliers/NaNs."
                        )
                    
                    df_clean.loc[remaining_nans, col] = global_stat
                    
        return df_clean